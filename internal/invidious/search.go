package invidious

import (
	"fmt"
	"net/url"
)

type searchVideoThumbnail struct {
	Quality string `json:"quality"`
	Url     string `json:"url"`
	Width   int32  `json:"width"`
	Height  int32  `json:"height"`
}

type searchAuthorThumbnail struct {
	Url    string `json:"url"`
	Width  int32  `json:"width"`
	Height int32  `json:"height"`
}

type SearchOption struct {
	Page     int32    `json:"page"`
	SortBy   string   `json:"sortBy"`
	Date     string   `json:"date"`
	Duration string   `json:"duration"`
	Type     string   `json:"type"`
	Features []string `json:"features"`
	Region   string   `json:"region"`
}

type SearchItem struct {
	// shared
	Type      string `json:"type"`
	Title     string `json:"title"`
	VideoId   string `json:"videoId"`
	Author    string `json:"author"`
	AuthorId  string `json:"authorId"`
	AuthorUrl string `json:"authorUrl"`
	ViewCount int64  `json:"viewCount"`

	// video
	VideoThumbnails []searchVideoThumbnail `json:"videoThumbnails"`
	Description     string                 `json:"description"`
	DescriptionHtml string                 `json:"descriptionHtml"`
	Published       int64                  `json:"published"`
	PublishedText   string                 `json:"publishedText"`
	LengthSeconds   int32                  `json:"lengthSeconds"`
	LiveNow         bool                   `json:"liveNow"`
	Paid            bool                   `json:"paid"`
	Premium         bool                   `json:"premium"`

	// playlist
	AuthorVerified    bool    `json:"authorVerified"`
	PlaylistId        string  `json:"playlistId"`
	PlaylistThumbnail string  `json:"playlistThumbnail"`
	Videos            []Video `json:"videos"`

	// channel
	AuthorThumbnails []searchAuthorThumbnail `json:"authorThumbnails"`
	AutoGenerated    bool                    `json:"autoGenerated"`
	SubCount         int32                   `json:"subCount"`
	VideoCount       int32                   `json:"videoCount"`
}

// sortBy: "relevance", "rating", "upload_date", "view_count"
// date: "hour", "today", "week", "month", "year"
// duration: "short", "long", "medium"
// type: (default all) "video", "playlist", "channel", "movie", "show", "all"
// features: (array containing one or more) "hd", "subtitles", "creative_commons", "3d", "live", "purchased", "4k", "360", "location", "hdr", "vr180"
// region (default US) ISO 3166 country code
func (s *Session) Search(query string, option ...SearchOption) ([]SearchItem, error) {
	if len(query) < 3 {
		return nil, fmt.Errorf("query needs to be at least 3 characters long")
	}

	values := url.Values{}
	if len(option) >= 1 {
		if option[0].Page > 0 {
			values.Set("page", fmt.Sprintf("%d", option[0].Page))
		}

		if option[0].SortBy != "" {
			values.Set("sort_by", option[0].SortBy)
		}

		if option[0].Date != "" {
			values.Set("date", option[0].Date)
		}

		if option[0].Duration != "" {
			values.Set("duration", option[0].Duration)
		}

		if option[0].Type != "" {
			values.Set("type", option[0].Type)
		}

		if option[0].Region != "" {
			values.Set("region", option[0].Region)
		}

		for _, feature := range option[0].Features {
			values.Add("features", feature)
		}
	}

	values.Set("q", query)

	endpoint := fmt.Sprintf("/api/v1/search?%s", values.Encode())

	searchItems := []SearchItem{}
	if err := s.makeRequest(endpoint, "GET", nil, nil, &searchItems); err != nil {
		return nil, err
	}

	for index := range searchItems {
		switch searchItems[index].Type {
		case "playlist":
			searchItems[index].Videos = fixCaptions(s.instance.ApiUrl, searchItems[index].Videos...)
		case "video":
			searchItems[index].Videos = fixHtmlDescription(s.instance.ApiUrl, searchItems[index].Videos...)
			searchItems[index].Videos = proxyThumbnails(searchItems[index].Videos...)
		case "channel":
			searchItems[index].Videos = proxyThumbnails(searchItems[index].Videos...)
		}
	}

	return searchItems, nil
}
